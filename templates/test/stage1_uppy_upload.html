{% extends "base.html" %}

{% block title %}Test Stage 1: Uppy Upload - Viral Clips{% endblock %}

{% block extra_head %}
<!-- Uppy CSS -->
<link href="https://releases.transloadit.com/uppy/v3.27.0/uppy.min.css" rel="stylesheet">
<style>
    /* Custom Uppy theme overrides for dark mode */
    .uppy-Dashboard {
        background-color: #1f2937 !important;
    }
    .uppy-Dashboard-inner {
        background-color: #1f2937 !important;
        border-color: #374151 !important;
    }
    .uppy-Dashboard-innerWrap {
        background-color: #1f2937 !important;
    }
    .uppy-Dashboard-AddFiles {
        border-color: #4b5563 !important;
    }
    .uppy-Dashboard-AddFiles-title {
        color: #e5e7eb !important;
    }
    .uppy-Dashboard-note {
        color: #9ca3af !important;
    }
    .uppy-DashboardTab-name {
        color: #d1d5db !important;
    }
    .uppy-Dashboard-Item {
        background-color: #374151 !important;
        border-color: #4b5563 !important;
    }
    .uppy-Dashboard-Item-name {
        color: #f3f4f6 !important;
    }
    .uppy-Dashboard-Item-statusSize {
        color: #9ca3af !important;
    }
    .uppy-StatusBar {
        background-color: #374151 !important;
    }
    .uppy-StatusBar-content {
        color: #e5e7eb !important;
    }
    .uppy-StatusBar-statusPrimary {
        color: #e5e7eb !important;
    }
    .uppy-StatusBar-statusSecondary {
        color: #9ca3af !important;
    }
    .uppy-StatusBar-actionBtn--upload {
        background-color: #7c3aed !important;
    }
    .uppy-StatusBar-actionBtn--upload:hover {
        background-color: #6d28d9 !important;
    }
    .uppy-DashboardContent-bar {
        background-color: #374151 !important;
        border-color: #4b5563 !important;
    }
    .uppy-DashboardContent-title {
        color: #e5e7eb !important;
    }
    .uppy-Dashboard-browse {
        color: #a78bfa !important;
    }
    .uppy-Dashboard-dropFilesHereHint {
        color: #9ca3af !important;
        border-color: #4b5563 !important;
    }
    /* Progress bar colors */
    .uppy-StatusBar-progress {
        background-color: #7c3aed !important;
    }
    .uppy-StatusBar.is-complete .uppy-StatusBar-progress {
        background-color: #10b981 !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="min-h-screen bg-gray-900 py-12 px-4 sm:px-6 lg:px-8">
    <div class="max-w-4xl mx-auto">
        <!-- Header -->
        <div class="mb-8">
            <h1 class="text-3xl font-bold text-white mb-2">üß™ Stage 1 Test: Uppy + S3 Multipart Upload</h1>
            <p class="text-gray-400">Upload large files directly to S3 with Uppy's polished UI and built-in resilience.</p>
            <div class="mt-4 bg-purple-900/20 border border-purple-700/50 rounded-lg p-4">
                <p class="text-purple-300 text-sm">
                    <strong>Features:</strong> Direct S3 upload ‚Ä¢ Parallel chunks ‚Ä¢ Pause/Resume ‚Ä¢ Automatic retry ‚Ä¢ Progress tracking ‚Ä¢ localStorage persistence
                </p>
            </div>
        </div>

        <!-- Uppy Dashboard -->
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 border border-gray-700 mb-8">
            <h2 class="text-xl font-semibold text-white mb-4">Upload with Uppy</h2>
            <div id="uppy-dashboard"></div>
        </div>

        <!-- Upload Status/Events Log -->
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 border border-gray-700 mb-8">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-white">Upload Events</h2>
                <button id="clear-log" class="text-sm text-gray-400 hover:text-white">Clear</button>
            </div>
            <div id="event-log" class="bg-gray-900 rounded-lg p-4 h-64 overflow-y-auto font-mono text-sm">
                <div class="text-gray-500">Waiting for upload events...</div>
            </div>
        </div>

        <!-- Upload Result -->
        <div id="result-section" class="hidden">
            <div class="bg-gray-800 rounded-lg shadow-xl p-8 border border-gray-700">
                <h2 class="text-xl font-semibold text-white mb-6">Upload Complete</h2>
                <div id="result-content" class="space-y-4">
                    <!-- Results will be populated here -->
                </div>
                
                <!-- Next Step -->
                <div class="mt-8 pt-6 border-t border-gray-700">
                    <h3 class="text-lg font-medium text-white mb-4">Next Steps</h3>
                    <div class="flex space-x-4">
                        <button id="extract-audio-btn" class="hidden bg-blue-600 text-white px-6 py-3 rounded-lg font-medium hover:bg-blue-500 transition-colors">
                            Extract Audio (Video Only)
                        </button>
                        <a href="{% url 'test-stage2' %}" class="bg-primary-600 text-white px-6 py-3 rounded-lg font-medium hover:bg-primary-500 transition-colors inline-block">
                            Continue to Stage 2 ‚Üí
                        </a>
                        <button id="new-upload-btn" class="bg-gray-600 text-white px-6 py-3 rounded-lg font-medium hover:bg-gray-500 transition-colors">
                            New Upload
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Back link -->
        <div class="mt-8 text-center">
            <a href="{% url 'test-stage1' %}" class="text-primary-400 hover:text-primary-300">
                ‚Üê Back to Basic Upload
            </a>
            <span class="text-gray-600 mx-4">|</span>
            <a href="{% url 'home' %}" class="text-gray-400 hover:text-gray-300">
                Back to Home
            </a>
        </div>
    </div>
</div>

<!-- Uppy JS -->
<script src="https://releases.transloadit.com/uppy/v3.27.0/uppy.min.js"></script>

<script>
    // Get auth token
    function getAuthToken() {
        return localStorage.getItem('auth_token');
    }

    // Get auth headers
    function getAuthHeaders() {
        const token = getAuthToken();
        return {
            'Content-Type': 'application/json',
            'Authorization': token ? `Bearer ${token}` : ''
        };
    }

    // Event logger
    const eventLog = document.getElementById('event-log');
    function logEvent(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const colors = {
            info: 'text-blue-400',
            success: 'text-green-400',
            error: 'text-red-400',
            warning: 'text-yellow-400',
            progress: 'text-purple-400'
        };
        const entry = document.createElement('div');
        entry.className = `${colors[type] || 'text-gray-400'} mb-1`;
        entry.innerHTML = `<span class="text-gray-500">[${timestamp}]</span> ${message}`;
        
        // Remove "waiting" message if present
        const waiting = eventLog.querySelector('.text-gray-500');
        if (waiting && waiting.textContent.includes('Waiting')) {
            waiting.remove();
        }
        
        eventLog.appendChild(entry);
        eventLog.scrollTop = eventLog.scrollHeight;
    }

    document.getElementById('clear-log').addEventListener('click', () => {
        eventLog.innerHTML = '<div class="text-gray-500">Waiting for upload events...</div>';
    });

    // Format bytes
    function formatBytes(bytes, decimals = 2) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    // Store upload results
    let uploadResults = [];

    // Calculate optimal part size (matching our backend logic)
    function calculatePartSize(fileSize) {
        const MIN_PART_SIZE = 5 * 1024 * 1024;      // 5MB minimum (S3 requirement)
        const MAX_PART_SIZE = 500 * 1024 * 1024;   // 500MB maximum
        const TARGET_PARTS = 100;                   // Aim for ~100 parts
        
        let partSize = Math.ceil(fileSize / TARGET_PARTS);
        partSize = Math.max(partSize, MIN_PART_SIZE);
        partSize = Math.min(partSize, MAX_PART_SIZE);
        
        return partSize;
    }

    // Initialize Uppy with S3 Multipart
    const uppy = new Uppy.Uppy({
        id: 'uppy-s3-multipart',
        autoProceed: false,
        allowMultipleUploadBatches: true,
        restrictions: {
            maxFileSize: 20 * 1024 * 1024 * 1024, // 20GB
            allowedFileTypes: ['video/*', 'audio/*'],
            maxNumberOfFiles: 5
        }
    });

    // Add Dashboard plugin
    uppy.use(Uppy.Dashboard, {
        target: '#uppy-dashboard',
        inline: true,
        height: 400,
        width: '100%',
        showProgressDetails: true,
        showRemoveButtonAfterComplete: true,
        note: 'Video or audio files up to 20GB. Direct S3 upload with pause/resume.',
        proudlyDisplayPoweredByUppy: false,
        theme: 'dark',
        locale: {
            strings: {
                dropPasteFiles: 'Drop files here or %{browseFiles}',
                browseFiles: 'browse files'
            }
        }
    });

    // Add AwsS3Multipart plugin with custom companion functions
    uppy.use(Uppy.AwsS3Multipart, {
        // Use our Django backend for S3 operations
        companionUrl: null, // We're not using Companion server
        
        // Number of concurrent part uploads
        limit: 6,
        
        // Retry configuration
        retryDelays: [0, 1000, 3000, 5000, 10000],
        
        // Custom function to create multipart upload
        async createMultipartUpload(file) {
            logEvent(`Creating multipart upload for ${file.name}...`, 'info');
            
            const partSize = calculatePartSize(file.size);
            
            const response = await fetch('/api/upload/multipart/initiate/', {
                method: 'POST',
                headers: getAuthHeaders(),
                body: JSON.stringify({
                    filename: file.name,
                    content_type: file.type,
                    file_size: file.size,
                    part_size: partSize
                })
            });
            
            // Check for auth errors
            if (response.status === 401 || response.status === 403) {
                logEvent('Authentication required - please log in again', 'error');
                throw new Error('Session expired. Please log in again.');
            }
            
            const data = await response.json();
            
            if (!data.success) {
                throw new Error(data.error || 'Failed to initiate upload');
            }
            
            logEvent(`Upload initiated: ${data.num_parts} parts, ${formatBytes(partSize)} each`, 'success');
            
            // Store metadata for later
            file.s3Multipart = {
                uploadId: data.upload_id,
                key: data.s3_key,
                jobId: data.job_id,
                numParts: data.num_parts,
                partSize: partSize
            };
            
            return {
                uploadId: data.upload_id,
                key: data.s3_key
            };
        },
        
        // Custom function to get presigned URLs for parts
        async signPart(file, { uploadId, key, partNumber, body }) {
            logEvent(`Getting presigned URL for part ${partNumber}...`, 'progress');
            
            const response = await fetch('/api/upload/multipart/urls/', {
                method: 'POST',
                headers: getAuthHeaders(),
                body: JSON.stringify({
                    upload_id: uploadId,
                    s3_key: key,
                    part_numbers: [partNumber]
                })
            });
            
            const data = await response.json();
            
            if (!data.success || !data.urls || data.urls.length === 0) {
                throw new Error(`Failed to get URL for part ${partNumber}`);
            }
            
            return {
                url: data.urls[0].url,
                headers: {}
            };
        },
        
        // Custom function to complete multipart upload
        async completeMultipartUpload(file, { uploadId, key, parts }) {
            logEvent(`Completing upload with ${parts.length} parts...`, 'info');
            
            // Sort parts by part number (S3 requirement)
            const sortedParts = parts.sort((a, b) => a.PartNumber - b.PartNumber);
            
            const response = await fetch('/api/upload/multipart/complete/', {
                method: 'POST',
                headers: getAuthHeaders(),
                body: JSON.stringify({
                    upload_id: uploadId,
                    s3_key: key,
                    parts: sortedParts
                })
            });
            
            const data = await response.json();
            
            if (!data.success) {
                throw new Error(data.error || 'Failed to complete upload');
            }
            
            logEvent(`‚úì Upload complete: ${file.name}`, 'success');
            
            // Store result for display
            uploadResults.push({
                name: file.name,
                size: file.size,
                type: file.type,
                s3Key: key,
                publicUrl: data.public_url,
                jobId: file.s3Multipart?.jobId
            });
            
            return { location: data.public_url };
        },
        
        // Custom function to abort multipart upload
        async abortMultipartUpload(file, { uploadId, key }) {
            logEvent(`Aborting upload for ${file.name}...`, 'warning');
            
            try {
                await fetch('/api/upload/multipart/abort/', {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({
                        upload_id: uploadId,
                        s3_key: key
                    })
                });
                logEvent(`Upload aborted: ${file.name}`, 'warning');
            } catch (error) {
                console.error('Failed to abort upload:', error);
            }
        },
        
        // Custom function to list uploaded parts (for resume)
        async listParts(file, { uploadId, key }) {
            // For now, return empty array (no resume from previous session)
            // Could implement server-side listParts if needed
            return [];
        }
    });

    // Event handlers
    uppy.on('file-added', (file) => {
        logEvent(`File added: ${file.name} (${formatBytes(file.size)})`, 'info');
    });

    uppy.on('file-removed', (file, reason) => {
        logEvent(`File removed: ${file.name} (${reason})`, 'warning');
    });

    uppy.on('upload', (data) => {
        logEvent(`Upload started for ${data.fileIDs.length} file(s)`, 'info');
    });

    uppy.on('upload-progress', (file, progress) => {
        const percent = ((progress.bytesUploaded / progress.bytesTotal) * 100).toFixed(1);
        // Only log at 10% intervals to avoid spam
        const loggedPercent = Math.floor(percent / 10) * 10;
        if (!file._lastLoggedPercent || file._lastLoggedPercent !== loggedPercent) {
            file._lastLoggedPercent = loggedPercent;
            if (loggedPercent > 0) {
                logEvent(`${file.name}: ${loggedPercent}% (${formatBytes(progress.bytesUploaded)} / ${formatBytes(progress.bytesTotal)})`, 'progress');
            }
        }
    });

    uppy.on('upload-success', (file, response) => {
        logEvent(`‚úì Upload complete: ${file.name}`, 'success');
    });

    uppy.on('upload-error', (file, error, response) => {
        logEvent(`‚úó Upload failed: ${file.name} - ${error.message}`, 'error');
        console.error('Upload error:', error, response);
    });

    uppy.on('complete', (result) => {
        logEvent(`All uploads complete: ${result.successful.length} succeeded, ${result.failed.length} failed`, 
                 result.failed.length > 0 ? 'warning' : 'success');
        
        if (result.successful.length > 0) {
            showResults();
        }
    });

    uppy.on('upload-retry', (fileID) => {
        const file = uppy.getFile(fileID);
        logEvent(`Retrying upload: ${file.name}`, 'warning');
    });

    uppy.on('retry-all', () => {
        logEvent('Retrying all failed uploads...', 'warning');
    });

    uppy.on('pause-all', () => {
        logEvent('All uploads paused', 'warning');
    });

    uppy.on('resume-all', () => {
        logEvent('All uploads resumed', 'info');
    });

    uppy.on('restriction-failed', (file, error) => {
        logEvent(`Restriction failed for ${file ? file.name : 'file'}: ${error.message}`, 'error');
    });

    // Show results
    function showResults() {
        const resultSection = document.getElementById('result-section');
        const resultContent = document.getElementById('result-content');
        
        resultContent.innerHTML = uploadResults.map((result) => {
            const isVideo = result.type && result.type.startsWith('video/');
            
            return `
                <div class="bg-gray-700 rounded-lg p-4">
                    <div class="flex items-start justify-between">
                        <div class="flex items-center space-x-3">
                            <svg class="h-8 w-8 ${isVideo ? 'text-purple-400' : 'text-green-400'}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                ${isVideo ? 
                                    '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />' :
                                    '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3" />'
                                }
                            </svg>
                            <div>
                                <p class="text-sm font-medium text-white">${result.name}</p>
                                <p class="text-xs text-gray-400">${formatBytes(result.size)} ‚Ä¢ ${result.type || 'unknown'}</p>
                            </div>
                        </div>
                        <span class="text-green-400 text-sm">‚úì Uploaded</span>
                    </div>
                    <div class="mt-3 pt-3 border-t border-gray-600">
                        <p class="text-xs text-gray-400 break-all">S3 Key: <code class="text-purple-400">${result.s3Key}</code></p>
                        ${result.publicUrl ? `<p class="text-xs text-gray-400 mt-1">URL: <a href="${result.publicUrl}" target="_blank" class="text-blue-400 hover:underline">${result.publicUrl.substring(0, 60)}...</a></p>` : ''}
                    </div>
                </div>
            `;
        }).join('');
        
        // Show extract audio button if any video was uploaded
        const hasVideo = uploadResults.some(r => r.type && r.type.startsWith('video/'));
        if (hasVideo) {
            document.getElementById('extract-audio-btn').classList.remove('hidden');
        }
        
        resultSection.classList.remove('hidden');
        resultSection.scrollIntoView({ behavior: 'smooth' });
    }

    // New upload button
    document.getElementById('new-upload-btn').addEventListener('click', () => {
        uploadResults = [];
        uppy.cancelAll();
        document.getElementById('result-section').classList.add('hidden');
        document.getElementById('extract-audio-btn').classList.add('hidden');
        eventLog.innerHTML = '<div class="text-gray-500">Waiting for upload events...</div>';
    });

    // Extract audio button handler
    document.getElementById('extract-audio-btn').addEventListener('click', async () => {
        const videoResult = uploadResults.find(r => r.type && r.type.startsWith('video/'));
        if (!videoResult) return;
        
        logEvent(`Extracting audio from ${videoResult.name}...`, 'info');
        
        try {
            const response = await fetch('/api/upload/extract-audio/', {
                method: 'POST',
                headers: getAuthHeaders(),
                body: JSON.stringify({
                    s3_key: videoResult.s3Key,
                    job_id: videoResult.jobId
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                logEvent(`‚úì Audio extracted: ${data.audio_url || 'Processing...'}`, 'success');
            } else {
                logEvent(`‚úó Audio extraction failed: ${data.error}`, 'error');
            }
        } catch (error) {
            logEvent(`‚úó Audio extraction error: ${error.message}`, 'error');
        }
    });

    // Log initialization
    logEvent('Uppy + S3 Multipart initialized', 'success');
    logEvent('Direct S3 upload with 6 parallel chunks', 'info');
    logEvent(`Max file size: ${formatBytes(20 * 1024 * 1024 * 1024)}`, 'info');
    
    // Check authentication status
    const token = getAuthToken();
    if (!token) {
        logEvent('‚ö†Ô∏è No auth token found - you may need to log in', 'warning');
    } else {
        // Verify token is still valid
        fetch('/api/auth/verify/', {
            method: 'POST',
            headers: getAuthHeaders()
        }).then(response => {
            if (response.status === 401 || response.status === 403) {
                logEvent('‚ö†Ô∏è Session expired - please log in again', 'warning');
            } else {
                logEvent('‚úì Authenticated', 'success');
            }
        }).catch(() => {
            logEvent('Could not verify auth status', 'warning');
        });
    }
</script>
{% endblock %}
